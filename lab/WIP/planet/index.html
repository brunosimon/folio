<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Template - Three.js - GUI - Stats - Shaders - Multi-composer - World - Classes</title>
    <link rel="stylesheet" href="src/css/style.css">
</head>
<body>
    <canvas id="three-canvas"></canvas>

    <!-- PLANET SHADER MATERIAL -->
    <script type="x-shader/x-vertex" id="planet-vertex-shader">

        varying vec3 vNormal;
        varying vec3 cameraVector;
        varying vec3 vPosition;
        varying vec2 vUv;

        void main() {
            vNormal = normal;
            vec4 vPosition4 = modelMatrix * vec4(position, 1.0);
            vPosition = vPosition4.xyz;
            cameraVector = cameraPosition - vPosition;
            vUv = uv;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-fragment-shader">

        uniform vec3 pointLightPosition;
        uniform sampler2D map;
        uniform sampler2D normalMap;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 cameraVector;
        varying vec2 vUv;

        mat4 rotationMatrix(vec3 axis, float angle)
        {
            axis = normalize(axis);
            float s = sin(angle);
            float c = cos(angle);
            float oc = 1.0 - c;

            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                        0.0,                                0.0,                                0.0,                                1.0);
        }

        vec3 bumpNormal(sampler2D normalMap, vec2 vUv)
        {
            vec3 bumpedNormal = normalize(texture2D(normalMap, vUv).xyz * 2.0 - 1.0);

            vec3 y_axis = vec3(0,1,0);
            float rot_angle = acos(dot(bumpedNormal,y_axis));
            vec3 rot_axis = normalize(cross(bumpedNormal,y_axis));
            return vec3(rotationMatrix(rot_axis, rot_angle) * vec4(vNormal, 1.0));
        }

        void main()
        {
            float PI = 3.14159265358979323846264;
            vec3 light = pointLightPosition - vPosition;
            vec3 cameraDir = normalize(cameraVector);
            vec3 newNormal = bumpNormal(normalMap, vUv);

            light = normalize(light);

            float lightAngle = max(0.0, dot(newNormal, light));
            float viewAngle = max(0.0, dot(vNormal, cameraDir));
            float adjustedLightAngle = min(0.6, lightAngle) / 0.6;
            float adjustedViewAngle = min(0.65, viewAngle) / 0.65;
            float invertedViewAngle = pow(acos(viewAngle), 3.0) * 0.4;

            float dProd = 0.0;
            dProd += 0.5 * lightAngle;
            dProd += 0.2 * lightAngle * (invertedViewAngle - 0.1);
            dProd += invertedViewAngle * 0.5 * (max(-0.35, dot(vNormal, light)) + 0.35);
            dProd *= 0.7 + pow(invertedViewAngle/(PI/2.0), 2.0);

            dProd *= 0.5;
            vec4 atmColor = vec4(dProd * 0.5, dProd * 0.5, dProd, 1.0);

            vec4 texelColor = texture2D(map, vUv) * min(asin(lightAngle), 1.0);
            gl_FragColor = texelColor + min(atmColor, 0.8);
            /*gl_FragColor = texture2D(map, vUv);*/
        }

    </script>

    <!-- PLANET TEXTURE SHADER -->
    <script type="x-shader/x-vertex" id="planet-texture-vertex-shader">

        varying vec2 vUv;

        void main()
        {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-texture-fragment-shader">

        varying vec2 vUv;
        uniform int index;

        int mod(int x, int m)
        {
            return int(mod(float(x), float(m)));
        }

        float random5(vec3 co)
        {
            return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,1.23456))) * 43758.5453);
        }


        float random4(float x, float y, float z)
        {
            return random5(vec3(x, y, z));
        }

        float random4(int x, int y, int z)
        {
            return random4(float(x), float(y), float(z));
        }

        float interpolation(float a, float b, float x)
        {
            float ft = x * 3.1415927;
            float f = (1.0 - cos(ft)) * 0.5;
            return a*(1.0-f) + b*f;
        }

        float tricosine(vec3 coordFloat)
        {
            vec3 coord0 = vec3(floor(coordFloat.x), floor(coordFloat.y), floor(coordFloat.z));
            vec3 coord1 = vec3(coord0.x+1.0, coord0.y+1.0, coord0.z+1.0);
            float xd    = (coordFloat.x - coord0.x)/max(1.0, (coord1.x-coord0.x));
            float yd    = (coordFloat.y - coord0.y)/max(1.0, (coord1.y-coord0.y));
            float zd    = (coordFloat.z - coord0.z)/max(1.0, (coord1.z-coord0.z));
            float c00   = interpolation(random4(coord0.x, coord0.y, coord0.z), random4(coord1.x, coord0.y, coord0.z), xd);
            float c10   = interpolation(random4(coord0.x, coord1.y, coord0.z), random4(coord1.x, coord1.y, coord0.z), xd);
            float c01   = interpolation(random4(coord0.x, coord0.y, coord1.z), random4(coord1.x, coord0.y, coord1.z), xd);
            float c11   = interpolation(random4(coord0.x, coord1.y, coord1.z), random4(coord1.x, coord1.y, coord1.z), xd);
            float c0    = interpolation(c00, c10, yd);
            float c1    = interpolation(c01, c11, yd);
            float c     = interpolation(c0, c1, zd);

            return c;
        }

        float nearestNeighbour(vec3 coordFloat)
        {
            return random4(int(floor(coordFloat.x)), int(floor(coordFloat.y)), int(floor(coordFloat.z)));
        }

        float helper(float x, float y, float z, float resolution)
        {
            x = (x+1.0)/2.0*resolution;
            y = (y+1.0)/2.0*resolution;
            z = (z+1.0)/2.0*resolution;

            vec3 coordFloat = vec3(x, y, z);
            float interpolated = tricosine(coordFloat);
            return interpolated*2.0 - 1.0;
        }

        vec3 scalarField(float x, float y, float z)
        {
            float resolution1 = 4.0;
            float resolution2 = 16.0;
            float resolution3 = 32.0;
            float resolution4 = 64.0;
            float resolution5 = 128.0;
            float resolutionMax = 256.0;

            vec3 coordFloat = vec3(0.0, 0.0, 0.0);

            float level1 = helper(x, y, z, resolution1);
            float level2 = helper(x, y, z, resolution2);
            float level3 = helper(x, y, z, resolution3);
            float level4 = helper(x, y, z, resolution4);
            float level5 = helper(x, y, z, resolution5);
            float levelMax = helper(x, y, z, resolutionMax);

            float c = 0.5;
            c *= 1.0 + level1*0.8;
            c *= 1.0 + level2*0.4;
            c *= 1.0 + level3*0.2;
            c *= 1.0 + level4*0.1;
            c *= 1.0 + level5*0.05;
            c *= 1.0 + levelMax*(0.025);

            if (c < 0.5) c *= 0.9;

            c = clamp(c, 0.0, 1.0);

            return vec3(c, c, c);
        }

        vec3 getSphericalCoord(int index, float x, float y, float width)
        {
            width /= 2.0;
            x -= width;
            y -= width;
            vec3 coord = vec3(0.0, 0.0, 0.0);

            if (index == 0) {coord.x=width; coord.y=-y; coord.z=-x;}
            else if (index == 1) {coord.x=-width; coord.y=-y; coord.z=x;}
            else if (index == 2) {coord.x=x; coord.y=width; coord.z=y;}
            else if (index == 3) {coord.x=x; coord.y=-width; coord.z=-y;}
            else if (index == 4) {coord.x=x; coord.y=-y; coord.z=width;}
            else if (index == 5) {coord.x=-x; coord.y=-y; coord.z=-width;}

            return normalize(coord);
        }

        void main()
        {
            float x = vUv.x;
            float y = 1.0 - vUv.y;
            vec3 sphericalCoord = getSphericalCoord(index, x*1024.0, y*1024.0, 1024.0);

            vec3 height = scalarField(sphericalCoord.x, sphericalCoord.y, sphericalCoord.z);

            gl_FragColor = vec4(height.x, height.y * 0.2, height.z * 0.2, 1.0);
        }

    </script>

    <!-- LIBS : MISC -->
    <script src="src/js/libs/dat.gui.min.js"></script>
    <script src="src/js/libs/rStats.js"></script>
    <script src="src/js/libs/jquery-2.1.1.min.js"></script>
    <script src="src/js/libs/class.js"></script>
    <script src="src/js/libs/matter-0.8.0.min.js"></script>
    <script src="src/js/libs/howler.min.js"></script>

    <!-- LIBS : THREE -->
    <script src="src/js/libs/three-js/three.min.js"></script>
    <script src="src/js/libs/three-js/shaders/AdditiveBlendingShader.js"></script>
    <script src="src/js/libs/three-js/shaders/ConvolutionShader.js"></script>
    <script src="src/js/libs/three-js/shaders/CopyShader.js"></script>
    <script src="src/js/libs/three-js/shaders/VerticalBlurShader.js"></script>
    <script src="src/js/libs/three-js/shaders/HorizontalBlurShader.js"></script>
    <script src="src/js/libs/three-js/shaders/VerticalTiltShiftShader.js"></script>
    <script src="src/js/libs/three-js/shaders/HorizontalTiltShiftShader.js"></script>
    <script src="src/js/libs/three-js/shaders/BrightnessContrastShader.js"></script>
    <script src="src/js/libs/three-js/shaders/FXAAShader.js"></script>
    <script src="src/js/libs/three-js/shaders/ColorCorrectionShader.js"></script>
    <script src="src/js/libs/three-js/postprocessing/EffectComposer.js"></script>
    <script src="src/js/libs/three-js/postprocessing/BloomPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/RenderPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/ShaderPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/MaskPass.js"></script>

    <!-- APP -->
    <script src="src/js/app/app.js"></script>

    <!-- CORE -->
    <script src="src/js/app/core/abstract.class.js"></script>
    <script src="src/js/app/core/event_emitter.class.js"></script>
    <script src="src/js/app/core/app.class.js"></script>

    <!-- COMPONENTS -->
    <script src="src/js/app/components/debug.class.js"></script>
    <script src="src/js/app/components/ui.class.js"></script>
    <script src="src/js/app/components/sounds.class.js"></script>
    <script src="src/js/app/components/world/world.class.js"></script>
    <script src="src/js/app/components/world/planet.class.js"></script>
    <script src="src/js/app/components/world/renderer.class.js"></script>

    <!-- TOOLS -->
    <script src="src/js/app/tools/browser.class.js"></script>
    <script src="src/js/app/tools/css.class.js"></script>
    <script src="src/js/app/tools/images.class.js"></script>
    <script src="src/js/app/tools/three_helper.class.js"></script>
    <script src="src/js/app/tools/keyboard.class.js"></script>
    <script src="src/js/app/tools/mouse.class.js"></script>
    <script src="src/js/app/tools/ticker.class.js"></script>

    <script>
        var app = new APP.CORE.App();
        app.start();
    </script>
</body>
</html>
