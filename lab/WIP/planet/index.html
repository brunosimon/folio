<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Procedural Planet</title>
    <link rel="stylesheet" href="src/css/style.css">
</head>
<body>
    <canvas id="three-canvas"></canvas>

    <!-- SKY SHADER -->
    <script type="x-shader/x-vertex" id="sky-vertex-shader">

        //
        // Atmospheric scattering vertex shader
        //
        // Author: Sean O'Neil
        //
        // Copyright (c) 2004 Sean O'Neil
        //

        uniform vec3 v3LightPosition;       // The direction vector to the light source
        uniform vec3 v3InvWavelength;       // 1 / pow(wavelength, 4) for the red, green, and blue channels
        uniform float fCameraHeight;        // The camera's current height
        uniform float fCameraHeight2;       // fCameraHeight^2
        uniform float fOuterRadius;         // The outer (atmosphere) radius
        uniform float fOuterRadius2;        // fOuterRadius^2
        uniform float fInnerRadius;         // The inner (planetary) radius
        uniform float fInnerRadius2;        // fInnerRadius^2
        uniform float fKrESun;              // Kr * ESun
        uniform float fKmESun;              // Km * ESun
        uniform float fKr4PI;               // Kr * 4 * PI
        uniform float fKm4PI;               // Km * 4 * PI
        uniform float fScale;               // 1 / (fOuterRadius - fInnerRadius)
        uniform float fScaleDepth;          // The scale depth (i.e. the altitude at which the atmosphere's average density is found)
        uniform float fScaleOverScaleDepth; // fScale / fScaleDepth

        const int   nSamples = 3;
        const float fSamples = 3.0;

        varying vec3 v3Direction;
        varying vec3 c0;
        varying vec3 c1;

        float scale(float fCos)
        {
            float x = 1.0 - fCos;

            return fScaleDepth * exp( - 0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( - 6.80 + x * 5.25 ) ) ) );
        }

        void main()
        {
            // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
            vec3 v3Ray = position - cameraPosition;
            float fFar = length( v3Ray );
            v3Ray /= fFar;

            // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)
            float B     = 2.0 * dot( cameraPosition, v3Ray );
            float C     = fCameraHeight2 - fOuterRadius2;
            float fDet  = max( 0.0, B * B - 4.0 * C );
            float fNear = 0.5 * (-B - sqrt(fDet));

            // Calculate the ray's starting position, then calculate its scattering offset
            vec3 v3Start = cameraPosition + v3Ray * fNear;
            fFar -= fNear;
            float fStartAngle  = dot( v3Ray, v3Start ) / fOuterRadius;
            float fStartDepth  = exp( - 1.0 / fScaleDepth );
            float fStartOffset = fStartDepth * scale( fStartAngle );
            //c0 = vec3(1.0, 0, 0) * fStartAngle;

            // Initialize the scattering loop variables
            float fSampleLength = fFar / fSamples;
            float fScaledLength = fSampleLength * fScale;
            vec3 v3SampleRay    = v3Ray * fSampleLength;
            vec3 v3SamplePoint  = v3Start + v3SampleRay * 0.5;

            //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);

            // Now loop through the sample rays
            vec3 v3FrontColor = vec3( 0.0, 0.0, 0.0 );
            for( int i = 0; i < nSamples; i++ )
            {
                float fHeight      = length( v3SamplePoint );
                float fDepth       = exp( fScaleOverScaleDepth * ( fInnerRadius - fHeight ) );
                float fLightAngle  = dot( v3LightPosition, v3SamplePoint ) / fHeight;
                float fCameraAngle = dot( v3Ray, v3SamplePoint ) / fHeight;
                float fScatter     = ( fStartOffset + fDepth * ( scale( fLightAngle ) - scale( fCameraAngle ) ) );
                vec3 v3Attenuate   = exp( - fScatter * ( v3InvWavelength * fKr4PI + fKm4PI ) );

                v3FrontColor  += v3Attenuate * ( fDepth * fScaledLength );
                v3SamplePoint += v3SampleRay;
            }

            // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            c0          = v3FrontColor * ( v3InvWavelength * fKrESun );
            c1          = v3FrontColor * fKmESun;

            v3Direction = cameraPosition - position;
        }
    </script>

    <script type="x-shader/x-fragment" id="sky-fragment-shader">

        //
        // Atmospheric scattering fragment shader
        //
        // Author: Sean O'Neil
        //
        // Copyright (c) 2004 Sean O'Neil
        //

        uniform vec3 v3LightPos;
        uniform float g;
        uniform float g2;

        varying vec3 v3Direction;
        varying vec3 c0;
        varying vec3 c1;

        // Calculates the Mie phase function
        float getMiePhase( float fCos, float fCos2, float g, float g2 )
        {
             return 1.5 * ( ( 1.0 - g2 ) / ( 2.0 + g2 ) ) * ( 1.0 + fCos2 ) / pow( 1.0 + g2 - 2.0 * g * fCos, 1.5 );
        }

        // Calculates the Rayleigh phase function
        float getRayleighPhase( float fCos2 )
        {
            return 0.75 + 0.75 * fCos2;
        }

        void main()
        {
            float fCos  = dot( v3LightPos, v3Direction ) / length( v3Direction );
            float fCos2 = fCos * fCos;

            vec3 color = getRayleighPhase( fCos2 ) * c0 + getMiePhase( fCos, fCos2, g, g2 ) * c1;

            gl_FragColor   = vec4( color, 1.0 );
            gl_FragColor.a = gl_FragColor.b;
        }

    </script>

    <!-- PLANET SHADER MATERIAL -->
    <script type="x-shader/x-vertex" id="planet-vertex-shader">

        uniform vec3 v3LightPosition;       // The direction vector to the light source
        uniform vec3 v3LightPosition2;      // Test
        uniform vec3 v3InvWavelength;       // 1 / pow(wavelength, 4) for the red, green, and blue channels
        uniform float fCameraHeight;        // The camera's current height
        uniform float fCameraHeight2;       // fCameraHeight^2
        uniform float fOuterRadius;         // The outer (atmosphere) radius
        uniform float fOuterRadius2;        // fOuterRadius^2
        uniform float fInnerRadius;         // The inner (planetary) radius
        uniform float fInnerRadius2;        // fInnerRadius^2
        uniform float fKrESun;              // Kr * ESun
        uniform float fKmESun;              // Km * ESun
        uniform float fKr4PI;               // Kr * 4 * PI
        uniform float fKm4PI;               // Km * 4 * PI
        uniform float fScale;               // 1 / (fOuterRadius - fInnerRadius)
        uniform float fScaleDepth;          // The scale depth (i.e. the altitude at which the atmosphere's average density is found)
        uniform float fScaleOverScaleDepth; // fScale / fScaleDepth
        uniform sampler2D tDiffuse;

        // varying vec3 v3Direction;
        varying vec3 c0;
        varying vec3 c1;
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vPosition;
        // varying float vSpecular;
        varying vec3 normalInterp;
        varying vec3 vertPos;
        varying vec3 vTest;

        const int nSamples = 3;
        const float fSamples = 3.0;

        float scale(float fCos)
        {
            float x = 1.0 - fCos;
            return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
        }

        void main(void)
        {
            // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)


            vPosition = vec3(modelMatrix * vec4(position, 1.0));

            vec3 v3Ray = vPosition - cameraPosition;
            float fFar = length(v3Ray);
            v3Ray /= fFar;

            // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)
            float B = 2.0 * dot(cameraPosition, v3Ray);
            float C = fCameraHeight2 - fOuterRadius2;
            float fDet = max(0.0, B*B - 4.0 * C);
            float fNear = 0.5 * (-B - sqrt(fDet));

            // Calculate the ray's starting position, then calculate its scattering offset
            vec3 v3Start = cameraPosition + v3Ray * fNear;
            fFar -= fNear;
            float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);
            float fCameraAngle = dot(-v3Ray, vPosition) / length(vPosition);
            float fLightAngle = dot(v3LightPosition, vPosition) / length(vPosition);
            float fCameraScale = scale(fCameraAngle);
            float fLightScale = scale(fLightAngle);
            float fCameraOffset = fDepth*fCameraScale;
            float fTemp = (fLightScale + fCameraScale);

            // Initialize the scattering loop variables
            float fSampleLength = fFar / fSamples;
            float fScaledLength = fSampleLength * fScale;
            vec3 v3SampleRay = v3Ray * fSampleLength;
            vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

            // Now loop through the sample rays
            vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
            vec3 v3Attenuate;
            for(int i=0; i<nSamples; i++)
            {
                float fHeight = length(v3SamplePoint);
                float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
                float fScatter = fDepth*fTemp - fCameraOffset;
                v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
                v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
                v3SamplePoint += v3SampleRay;
            }

            // Calculate the attenuation factor for the ground
            c0 = v3Attenuate;
            c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            vUv = uv;
            vNormal = normal;

            // // Specular version 1
            // vec4 vertPos4   = modelViewMatrix * vec4(position, 1.0);
            // vec3 vertPos    = vec3(vertPos4) / vertPos4.w;
            // vec3 lightDir   = normalize(v3LightPosition - vertPos);
            // vec3 reflectDir = reflect(-lightDir, normal);
            // vec3 viewDir    = normalize(-vertPos);

            // float lambertian = max(dot(lightDir,normal), 0.0);
            // float specular   = 0.0;

            // int mode = 4;

            // if(lambertian > 0.0)
            // {
            //     float specAngle = max(dot(reflectDir, viewDir), 0.0);
            //     // specular = pow(specAngle, 4.0);
            //     specular = pow(specAngle, 16.0);
            //     specular *= lambertian;
            // }

            // // vSpecular = vec4(lambertian*vec3(0.5, 0.0, 0.0) + specular*vec3(1.0, 1.0, 1.0), 1.0);
            // // vSpecular = vec4(1.0,1.0,1.0,specular);
            // vSpecular = specular;

            // Specular version 2
            vec4 vertPos4 = modelViewMatrix * vec4( position, 1.0 );

            // vertPos       = vec3( vertPos4 ) / vertPos4.w;
            vertPos       = vec3( vertPos4 );

            // normalInterp  = vec3(normalMatrix * vec4(normal, 0.0));
            normalInterp  = normalMatrix * normal;
            // normalInterp  = normal;

            vTest = vec3( modelViewMatrix * vec4( v3LightPosition2, 1.0 ) );
            // vTest = vec3(-300.0,0.0,-2000.0);
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-fragment-shader">
        uniform float time;

        uniform float fNightScale;
        uniform float fIceScale;
        uniform vec3 v3LightPosition;
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseNight;
        uniform sampler2D tGroundGradient;
        uniform sampler2D tIceGradient;

        varying vec3 c0;
        varying vec3 c1;
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vPosition;
        // varying float vSpecular;
        varying vec3 normalInterp;
        varying vec3 vertPos;
        varying vec3 vTest;

        void main (void)
        {
            // Data
            vec3 diffuseData = texture2D( tDiffuse, vUv ).xyz;

            // Ground / Ice
            vec3 groundColor = vec3( 0.0, 0.0, 0.0 );

            if( diffuseData.r * abs( vPosition.y / 100.0 ) < fIceScale )
                groundColor = texture2D( tGroundGradient, vec2( diffuseData.r, 0.0 ) ).xyz;
            else
                groundColor = texture2D( tIceGradient, vec2( diffuseData.r / ( 1.0 - fIceScale ) - fIceScale, 0.0 ) ).xyz;

            // Night
            vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;
            diffuseNightTex = vec3( 0.0, 0.0, 0.0 );
            // diffuseNightTex = vec3( diffuseData.g, diffuseData.g, diffuseData.g );
            vec3 night = 2.0 * fNightScale * diffuseNightTex * diffuseNightTex * (1.0 - c0);

            // Day
            vec3 day = groundColor * c0;
            // vec3 day = mix( groundColor, iceColor, diffuseData.g ) * c0;

            // Specular version 1
            // vec4 v4Specular = vec4(vSpecular) * vec4(1.0 - diffuseData.b) * vec4(1.0,0.5,0.5,1.0) * 1.0;

            // Specular version 2
            vec3 normal   = normalize( normalInterp );
            vec3 lightRelativePosition = v3LightPosition - cameraPosition;
            vec3 lightDir = normalize( vTest - vertPos );
            // vec3 lightDir = normalize( v3LightPosition - vertPos );

            float lambertian = max( dot( lightDir, normal ), 0.0 );
            float specular   = 0.0;

            if( lambertian > 0.0 )
            {
                vec3 reflectDir = reflect( - lightDir, normal );
                vec3 viewDir    = normalize( - vertPos );

                float specAngle = max( dot( reflectDir, viewDir ), 0.0 );
                specular = pow( specAngle, 4.0 );
                specular *= lambertian;
            }
            vec4 v4Specular = vec4( specular ) * vec4( 1.0 - diffuseData.b ) * vec4( 1.0, 0.5, 0.5, 1.0 ) * 1.0;

            // Frag color
            // gl_FragColor = vec4(c1, 1.0);  // Atmosphere
            // gl_FragColor = vec4(day, 1.0); // Texture
            // gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0); // Texture + Night texture + Atmosphere
            gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0) + vec4(1.0, 1.0, 1.0, 1.0) * v4Specular; // Texture + Night texture + Atmosphere + Specular
            // gl_FragColor = vec4(normal,1.0);
            // gl_FragColor = vec4(vertPos,1.0);
            // gl_FragColor = vec4(specular,specular,specular,1.0);
        }

    </script>


    <!-- PLANET TEXTURE SHADER -->
    <script type="x-shader/x-vertex" id="planet-texture-vertex-shader">

        varying vec2 vUv;

        void main()
        {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-texture-fragment-shader">

        varying vec2 vUv;
        uniform int index;

        vec3 seed = vec3( 12.9898, 78.233, 1.23456 ); // Not sure it's really the seed but it works like it

        int mod( int x, int m )
        {
            return int( mod( float( x ), float( m ) ) );
        }

        float random5( vec3 co )
        {
            return fract( sin( dot( co.xyz ,seed ) ) * 43758.5453 );
        }

        float random4( float x, float y, float z )
        {
            return random5(vec3(x, y, z));
        }

        float random4( int x, int y, int z )
        {
            return random4( float( x ), float( y ), float( z ) );
        }

        float interpolation( float a, float b, float x )
        {
            float ft = x * 3.1415927;
            float f  = ( 1.0 - cos( ft ) ) * 0.5;
            return a * ( 1.0 - f ) + b * f;
        }

        float tricosine( vec3 coordFloat )
        {
            vec3 coord0 = vec3( floor( coordFloat.x ), floor( coordFloat.y ), floor( coordFloat.z ) );
            vec3 coord1 = vec3( coord0.x + 1.0, coord0.y + 1.0, coord0.z + 1.0 );
            float xd    = ( coordFloat.x - coord0.x ) / max( 1.0, ( coord1.x - coord0.x ) );
            float yd    = ( coordFloat.y - coord0.y ) / max( 1.0, ( coord1.y - coord0.y ) );
            float zd    = ( coordFloat.z - coord0.z ) / max( 1.0, ( coord1.z - coord0.z ) );
            float c00   = interpolation( random4( coord0.x, coord0.y, coord0.z), random4( coord1.x, coord0.y, coord0.z ), xd );
            float c10   = interpolation( random4( coord0.x, coord1.y, coord0.z), random4( coord1.x, coord1.y, coord0.z ), xd );
            float c01   = interpolation( random4( coord0.x, coord0.y, coord1.z), random4( coord1.x, coord0.y, coord1.z ), xd );
            float c11   = interpolation( random4( coord0.x, coord1.y, coord1.z), random4( coord1.x, coord1.y, coord1.z ), xd );
            float c0    = interpolation( c00, c10, yd );
            float c1    = interpolation( c01, c11, yd );
            float c     = interpolation( c0, c1, zd );

            return c;
        }

        float nearestNeighbour(vec3 coordFloat)
        {
            return random4( int( floor( coordFloat.x ) ), int( floor( coordFloat.y ) ), int( floor( coordFloat.z ) ) );
        }

        float helper( float x, float y, float z, float resolution )
        {
            x = ( x + 1.0 ) / 2.0 * resolution;
            y = ( y + 1.0 ) / 2.0 * resolution;
            z = ( z + 1.0 ) / 2.0 * resolution;

            vec3 coordFloat    = vec3( x, y, z );
            float interpolated = tricosine( coordFloat );

            return interpolated * 2.0 - 1.0;
        }

        float getHeight( float x, float y, float z )
        {
            float h = 0.5;
            for( int i = 0; i < 5; ++i )
            {
                float resolution = pow( 2.0, 2.0 + float( i ) * 2.0 );
                float level      = helper( x, y, z, resolution );

                h *= 1.0 + level * ( 0.8 / ( pow( 2.0, 1.0 + float( i ) ) ) );
            }

            h = clamp( h, 0.0, 1.0 );

            return h;
        }

        vec4 getCloud( float x, float y, float z )
        {
            float h = 0.5;
            for( int i = 0; i < 7; ++i )
            {
                float resolution = pow( 2.0, 4.0 + float( i ) * 2.0 );
                float level      = helper( x, y, z, resolution );

                h *= 1.0 + level * ( 0.8 / ( pow( 2.0, 1.0 + float( i ) ) ) );
            }

            if(h < 0.6)
                h = 0.0;

            h = clamp( h, 0.0, 1.0 );

            // return vec4( 0.8, 0.8, 0.5, h );
            return vec4( 1.0, 1.0, 1.0, h );
        }

        vec4 getColor( float x, float y, float z, float height )
        {
            vec3 color;

            // Ground
            color.r = height;

            // Lights
            color.g = 0.0;
            if( height * abs( y ) > 0.45 && height * abs( y ) < 0.5 )
                color.g = 1.0;

            // Continent (for specular)
            if( height > 0.495 )
                color.b = 0.7;
            else
                color.b = 0.0;

            return vec4( color, 1.0 );
        }

        vec3 getSphericalCoord( int index, float x, float y, float width )
        {
            width *= 0.5;
            x     -= width;
            y     -= width;

            vec3 coord = vec3( 0.0, 0.0, 0.0 );

            if(index == 0)      { coord.x = width;   coord.y = - y;     coord.z = - x; }
            else if(index == 1) { coord.x = - width; coord.y = - y;     coord.z = x; }
            else if(index == 2) { coord.x = x;       coord.y = width;   coord.z = y; }
            else if(index == 3) { coord.x = x;       coord.y = - width; coord.z = - y; }
            else if(index == 4) { coord.x = x;       coord.y = - y;     coord.z = width; }
            else if(index == 5) { coord.x = - x;     coord.y = - y;     coord.z = - width; }

            return normalize( coord );
        }

        void main()
        {
            float x = vUv.x;
            float y = 1.0 - vUv.y;

            // Get sphetical coordinates
            vec3 sphericalCoord = getSphericalCoord( index, x * 1024.0, y * 1024.0, 1024.0 );

            // Get height
            float height = getHeight( sphericalCoord.x, sphericalCoord.y, sphericalCoord.z );

            // Get color
            vec4 color = getColor( sphericalCoord.x, sphericalCoord.y, sphericalCoord.z, height );
            // vec4 color = vec4(height,height,height,1);

            // Get cloud
            seed = vec3( 78.233, 1.23456, 12.9898 ); // Change seed
            vec4 cloud = getCloud( sphericalCoord.x, sphericalCoord.y, sphericalCoord.z );

            // gl_FragColor = mix( color, cloud, cloud.a );
            // gl_FragColor = mix( color, vec4(1) * color + vec4(1.0) * cloud, cloud.a );
            // gl_FragColor = vec4(0.5) * color + vec4(0.5) * cloud;
            gl_FragColor = color;
        }

    </script>

    <!-- LIBS : MISC -->
    <script src="src/js/libs/dat.gui.min.js"></script>
    <script src="src/js/libs/rStats.js"></script>
    <script src="src/js/libs/jquery-2.1.1.min.js"></script>
    <script src="src/js/libs/class.js"></script>
    <script src="src/js/libs/matter-0.8.0.min.js"></script>
    <script src="src/js/libs/howler.min.js"></script>

    <!-- LIBS : THREE -->
    <script src="src/js/libs/three-js/three.min.js"></script>
    <script src="src/js/libs/three-js/shaders/AdditiveBlendingShader.js"></script>
    <script src="src/js/libs/three-js/shaders/ConvolutionShader.js"></script>
    <script src="src/js/libs/three-js/shaders/CopyShader.js"></script>
    <script src="src/js/libs/three-js/shaders/VerticalBlurShader.js"></script>
    <script src="src/js/libs/three-js/shaders/HorizontalBlurShader.js"></script>
    <script src="src/js/libs/three-js/shaders/VerticalTiltShiftShader.js"></script>
    <script src="src/js/libs/three-js/shaders/HorizontalTiltShiftShader.js"></script>
    <script src="src/js/libs/three-js/shaders/BrightnessContrastShader.js"></script>
    <script src="src/js/libs/three-js/shaders/FXAAShader.js"></script>
    <script src="src/js/libs/three-js/shaders/ColorCorrectionShader.js"></script>
    <script src="src/js/libs/three-js/postprocessing/EffectComposer.js"></script>
    <script src="src/js/libs/three-js/postprocessing/BloomPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/RenderPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/ShaderPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/MaskPass.js"></script>

    <!-- APP -->
    <script src="src/js/app/app.js"></script>

    <!-- CORE -->
    <script src="src/js/app/core/abstract.class.js"></script>
    <script src="src/js/app/core/event_emitter.class.js"></script>
    <script src="src/js/app/core/app.class.js"></script>

    <!-- COMPONENTS -->
    <script src="src/js/app/components/debug.class.js"></script>
    <script src="src/js/app/components/ui.class.js"></script>
    <script src="src/js/app/components/sounds.class.js"></script>
    <script src="src/js/app/components/world/world.class.js"></script>
    <script src="src/js/app/components/world/renderer.class.js"></script>
    <script src="src/js/app/components/world/planet/planet.class.js"></script>
    <script src="src/js/app/components/world/planet/sky.class.js"></script>
    <script src="src/js/app/components/world/planet/ground.class.js"></script>
    <script src="src/js/app/components/world/planet/gradient_texture.class.js"></script>

    <!-- TOOLS -->
    <script src="src/js/app/tools/browser.class.js"></script>
    <script src="src/js/app/tools/css.class.js"></script>
    <script src="src/js/app/tools/images.class.js"></script>
    <script src="src/js/app/tools/three_helper.class.js"></script>
    <script src="src/js/app/tools/keyboard.class.js"></script>
    <script src="src/js/app/tools/mouse.class.js"></script>
    <script src="src/js/app/tools/ticker.class.js"></script>

    <script>
        var app = new APP.CORE.App();
        app.start();
    </script>
</body>
</html>
