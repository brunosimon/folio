<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Procedural Planet</title>
    <link rel="stylesheet" href="src/css/style.css">
</head>
<body>
    <canvas id="three-canvas"></canvas>

    <!-- SKY SHADER -->
    <script type="x-shader/x-vertex" id="sky-vertex-shader">

        //
        // Atmospheric scattering vertex shader
        //
        // Author: Sean O'Neil
        //
        // Copyright (c) 2004 Sean O'Neil
        //

        uniform vec3 v3LightPosition;       // The direction vector to the light source
        uniform vec3 v3InvWavelength;       // 1 / pow(wavelength, 4) for the red, green, and blue channels
        uniform float fCameraHeight;        // The camera's current height
        uniform float fCameraHeight2;       // fCameraHeight^2
        uniform float fOuterRadius;         // The outer (atmosphere) radius
        uniform float fOuterRadius2;        // fOuterRadius^2
        uniform float fInnerRadius;         // The inner (planetary) radius
        uniform float fInnerRadius2;        // fInnerRadius^2
        uniform float fKrESun;              // Kr * ESun
        uniform float fKmESun;              // Km * ESun
        uniform float fKr4PI;               // Kr * 4 * PI
        uniform float fKm4PI;               // Km * 4 * PI
        uniform float fScale;               // 1 / (fOuterRadius - fInnerRadius)
        uniform float fScaleDepth;          // The scale depth (i.e. the altitude at which the atmosphere's average density is found)
        uniform float fScaleOverScaleDepth; // fScale / fScaleDepth

        const int   nSamples = 3;
        const float fSamples = 3.0;

        varying vec3 v3Direction;
        varying vec3 c0;
        varying vec3 c1;

        float scale(float fCos)
        {
            float x = 1.0 - fCos;

            return fScaleDepth * exp( - 0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( - 6.80 + x * 5.25 ) ) ) );
        }

        void main()
        {
            // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
            vec3 v3Ray = position - cameraPosition;
            float fFar = length( v3Ray );
            v3Ray /= fFar;

            // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)
            float B     = 2.0 * dot( cameraPosition, v3Ray );
            float C     = fCameraHeight2 - fOuterRadius2;
            float fDet  = max( 0.0, B * B - 4.0 * C );
            float fNear = 0.5 * (-B - sqrt(fDet));

            // Calculate the ray's starting position, then calculate its scattering offset
            vec3 v3Start = cameraPosition + v3Ray * fNear;
            fFar -= fNear;
            float fStartAngle  = dot( v3Ray, v3Start ) / fOuterRadius;
            float fStartDepth  = exp( - 1.0 / fScaleDepth );
            float fStartOffset = fStartDepth * scale( fStartAngle );
            //c0 = vec3(1.0, 0, 0) * fStartAngle;

            // Initialize the scattering loop variables
            float fSampleLength = fFar / fSamples;
            float fScaledLength = fSampleLength * fScale;
            vec3 v3SampleRay    = v3Ray * fSampleLength;
            vec3 v3SamplePoint  = v3Start + v3SampleRay * 0.5;

            //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);

            // Now loop through the sample rays
            vec3 v3FrontColor = vec3( 0.0, 0.0, 0.0 );
            for( int i = 0; i < nSamples; i++ )
            {
                float fHeight      = length( v3SamplePoint );
                float fDepth       = exp( fScaleOverScaleDepth * ( fInnerRadius - fHeight ) );
                float fLightAngle  = dot( v3LightPosition, v3SamplePoint ) / fHeight;
                float fCameraAngle = dot( v3Ray, v3SamplePoint ) / fHeight;
                float fScatter     = ( fStartOffset + fDepth * ( scale( fLightAngle ) - scale( fCameraAngle ) ) );
                vec3 v3Attenuate   = exp( - fScatter * ( v3InvWavelength * fKr4PI + fKm4PI ) );

                v3FrontColor  += v3Attenuate * ( fDepth * fScaledLength );
                v3SamplePoint += v3SampleRay;
            }

            // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            c0          = v3FrontColor * ( v3InvWavelength * fKrESun );
            c1          = v3FrontColor * fKmESun;

            v3Direction = cameraPosition - position;
        }
    </script>

    <script type="x-shader/x-fragment" id="sky-fragment-shader">

        //
        // Atmospheric scattering fragment shader
        //
        // Author: Sean O'Neil
        //
        // Copyright (c) 2004 Sean O'Neil
        //

        uniform vec3 v3LightPos;
        uniform float g;
        uniform float g2;

        varying vec3 v3Direction;
        varying vec3 c0;
        varying vec3 c1;

        // Calculates the Mie phase function
        float getMiePhase( float fCos, float fCos2, float g, float g2 )
        {
             return 1.5 * ( ( 1.0 - g2 ) / ( 2.0 + g2 ) ) * ( 1.0 + fCos2 ) / pow( 1.0 + g2 - 2.0 * g * fCos, 1.5 );
        }

        // Calculates the Rayleigh phase function
        float getRayleighPhase( float fCos2 )
        {
            return 0.75 + 0.75 * fCos2;
        }

        void main()
        {
            float fCos  = dot( v3LightPos, v3Direction ) / length( v3Direction );
            float fCos2 = fCos * fCos;

            vec3 color = getRayleighPhase( fCos2 ) * c0 + getMiePhase( fCos, fCos2, g, g2 ) * c1;

            gl_FragColor   = vec4( color, 1.0 );
            gl_FragColor.a = gl_FragColor.b;
        }

    </script>

    <!-- PLANET SHADER MATERIAL -->
    <script type="x-shader/x-vertex" id="planet-vertex-shader">

        uniform vec3 v3LightPosition;       // The direction vector to the light source
        uniform vec3 v3InvWavelength;       // 1 / pow(wavelength, 4) for the red, green, and blue channels
        uniform float fCameraHeight;        // The camera's current height
        uniform float fCameraHeight2;       // fCameraHeight^2
        uniform float fOuterRadius;         // The outer (atmosphere) radius
        uniform float fOuterRadius2;        // fOuterRadius^2
        uniform float fInnerRadius;         // The inner (planetary) radius
        uniform float fInnerRadius2;        // fInnerRadius^2
        uniform float fKrESun;              // Kr * ESun
        uniform float fKmESun;              // Km * ESun
        uniform float fKr4PI;               // Kr * 4 * PI
        uniform float fKm4PI;               // Km * 4 * PI
        uniform float fScale;               // 1 / (fOuterRadius - fInnerRadius)
        uniform float fScaleDepth;          // The scale depth (i.e. the altitude at which the atmosphere's average density is found)
        uniform float fScaleOverScaleDepth; // fScale / fScaleDepth
        uniform sampler2D tDiffuse;

        // varying vec3 v3Direction;
        varying vec3 c0;
        varying vec3 c1;
        // varying vec3 vNormal;
        varying vec2 vUv;

        const int nSamples = 3;
        const float fSamples = 3.0;

        float scale(float fCos)
        {
            float x = 1.0 - fCos;
            return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
        }

        void main(void)
        {
            // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)


            vec3 vPosition = vec3(modelMatrix * vec4(position, 1.0));

            vec3 v3Ray = vPosition - cameraPosition;
            float fFar = length(v3Ray);
            v3Ray /= fFar;

            // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)
            float B = 2.0 * dot(cameraPosition, v3Ray);
            float C = fCameraHeight2 - fOuterRadius2;
            float fDet = max(0.0, B*B - 4.0 * C);
            float fNear = 0.5 * (-B - sqrt(fDet));

            // Calculate the ray's starting position, then calculate its scattering offset
            vec3 v3Start = cameraPosition + v3Ray * fNear;
            fFar -= fNear;
            float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);
            float fCameraAngle = dot(-v3Ray, vPosition) / length(vPosition);
            float fLightAngle = dot(v3LightPosition, vPosition) / length(vPosition);
            float fCameraScale = scale(fCameraAngle);
            float fLightScale = scale(fLightAngle);
            float fCameraOffset = fDepth*fCameraScale;
            float fTemp = (fLightScale + fCameraScale);

            // Initialize the scattering loop variables
            float fSampleLength = fFar / fSamples;
            float fScaledLength = fSampleLength * fScale;
            vec3 v3SampleRay = v3Ray * fSampleLength;
            vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

            // Now loop through the sample rays
            vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
            vec3 v3Attenuate;
            for(int i=0; i<nSamples; i++)
            {
                float fHeight = length(v3SamplePoint);
                float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
                float fScatter = fDepth*fTemp - fCameraOffset;
                v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
                v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
                v3SamplePoint += v3SampleRay;
            }

            // Calculate the attenuation factor for the ground
            c0 = v3Attenuate;
            c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);

          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          vUv = uv;
          // vNormal = normal;
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-fragment-shader">
        uniform float time;

        uniform float fNightScale;
        uniform vec3 v3LightPosition;
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseNight;

        varying vec3 c0;
        varying vec3 c1;
        // varying vec3 vNormal;
        varying vec2 vUv;

        void main (void)
        {

            float t = time;

            vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;

            vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;
            diffuseNightTex = vec3(0.0,0.0,0.0);

            vec3 day = diffuseTex * c0;
            vec3 night = 2.0 * fNightScale * diffuseNightTex * diffuseNightTex * (1.0 - c0);



            // gl_FragColor = vec4(c1, 1.0);
            gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);

        }

    </script>


    <!-- <script type="x-shader/x-vertex" id="planet-vertex-shader">

        varying vec3 vNormal;
        varying vec3 cameraVector;
        varying vec3 vPosition;
        varying vec2 vUv;

        void main()
        {
            vNormal         = normal;
            vec4 vPosition4 = modelMatrix * vec4(position, 1.0);
            vPosition       = vPosition4.xyz;
            cameraVector    = cameraPosition - vPosition;
            vUv             = uv;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-fragment-shader">

        uniform vec3      pointLightPosition;
        uniform sampler2D tDiffuse;
        uniform sampler2D normalMap;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 cameraVector;
        varying vec2 vUv;

        mat4 rotationMatrix( vec3 axis, float angle )
        {
            axis     = normalize( axis );
            float s  = cos( angle );
            float c  = sin( angle );
            float oc = 1.0 - c;

            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                        0.0,                                0.0,                                0.0,                                1.0);
        }

        vec3 bumpNormal( sampler2D normalMap, vec2 vUv )
        {
            vec3 bumpedNormal = normalize(texture2D(normalMap, vUv).xyz * 2.0 - 1.0);

            vec3 y_axis     = vec3(0,1,0);
            float rot_angle = acos( dot( bumpedNormal, y_axis ) );
            vec3 rot_axis   = normalize( cross( bumpedNormal, y_axis ) );
            return vec3( rotationMatrix( rot_axis, rot_angle ) * vec4( vNormal, 1.0 ) );
        }

        void main()
        {
            float PI       = 3.14159265358979323846264;
            vec3 light     = pointLightPosition - vPosition;
            vec3 cameraDir = normalize( cameraVector );
            vec3 newNormal = vNormal;
            // vec3 newNormal = bumpNormal( normalMap, vUv );

            light = normalize( light );

            // Angle
            float lightAngle         = max( 0.0, dot( newNormal, light ) );
            float viewAngle          = max( 0.0, dot( vNormal, cameraDir ) );
            float adjustedLightAngle = min( 0.6, lightAngle ) / 0.6;
            float adjustedViewAngle  = min( 0.65, viewAngle ) / 0.65;
            float invertedViewAngle  = pow( acos( viewAngle ), 3.0 ) * 0.4;

            // Atmosphere
            float dProd = 0.0;
            dProd += 0.5 * lightAngle;
            dProd += 0.2 * lightAngle * ( invertedViewAngle - 0.1 );
            dProd += invertedViewAngle * 0.5 * ( max( - 0.35, dot( vNormal, light ) ) + 0.35 );
            dProd *= 0.7 + pow( invertedViewAngle / ( PI / 2.0 ), 2.0 );
            dProd *= 0.5;
            vec4 atmColor = vec4( dProd * 0.2, dProd * 0.2, dProd, 1.0 );

            // Shadow
            vec4 texelColor = texture2D( tDiffuse, vUv ) * min( asin( lightAngle ), 1.0 );
            gl_FragColor    = texelColor + min( atmColor, 1.0 );

            // gl_FragColor = texture2D(map, vUv);
        }

    </script> -->

    <!-- PLANET TEXTURE SHADER -->
    <script type="x-shader/x-vertex" id="planet-texture-vertex-shader">

        varying vec2 vUv;

        void main()
        {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }

    </script>

    <script type="x-shader/x-fragment" id="planet-texture-fragment-shader">

        varying vec2 vUv;
        uniform int index;

        vec3 seed = vec3( 12.9898, 78.233, 1.23456 ); // Not sure it's really the seed but it works like it

        int mod( int x, int m )
        {
            return int( mod( float( x ), float( m ) ) );
        }

        float random5( vec3 co )
        {
            return fract( sin( dot( co.xyz ,seed ) ) * 43758.5453 );
        }


        float random4( float x, float y, float z )
        {
            return random5(vec3(x, y, z));
        }

        float random4( int x, int y, int z )
        {
            return random4( float( x ), float( y ), float( z ) );
        }

        float interpolation( float a, float b, float x )
        {
            float ft = x * 3.1415927;
            float f  = ( 1.0 - cos( ft ) ) * 0.5;
            return a * ( 1.0 - f ) + b * f;
        }

        float tricosine( vec3 coordFloat )
        {
            vec3 coord0 = vec3( floor( coordFloat.x ), floor( coordFloat.y ), floor( coordFloat.z ) );
            vec3 coord1 = vec3( coord0.x + 1.0, coord0.y + 1.0, coord0.z + 1.0 );
            float xd    = ( coordFloat.x - coord0.x ) / max( 1.0, ( coord1.x - coord0.x ) );
            float yd    = ( coordFloat.y - coord0.y ) / max( 1.0, ( coord1.y - coord0.y ) );
            float zd    = ( coordFloat.z - coord0.z ) / max( 1.0, ( coord1.z - coord0.z ) );
            float c00   = interpolation( random4( coord0.x, coord0.y, coord0.z), random4( coord1.x, coord0.y, coord0.z ), xd );
            float c10   = interpolation( random4( coord0.x, coord1.y, coord0.z), random4( coord1.x, coord1.y, coord0.z ), xd );
            float c01   = interpolation( random4( coord0.x, coord0.y, coord1.z), random4( coord1.x, coord0.y, coord1.z ), xd );
            float c11   = interpolation( random4( coord0.x, coord1.y, coord1.z), random4( coord1.x, coord1.y, coord1.z ), xd );
            float c0    = interpolation( c00, c10, yd );
            float c1    = interpolation( c01, c11, yd );
            float c     = interpolation( c0, c1, zd );

            return c;
        }

        float nearestNeighbour(vec3 coordFloat)
        {
            return random4( int( floor( coordFloat.x ) ), int( floor( coordFloat.y ) ), int( floor( coordFloat.z ) ) );
        }

        float helper( float x, float y, float z, float resolution )
        {
            x = ( x + 1.0 ) / 2.0 * resolution;
            y = ( y + 1.0 ) / 2.0 * resolution;
            z = ( z + 1.0 ) / 2.0 * resolution;

            vec3 coordFloat    = vec3( x, y, z );
            float interpolated = tricosine( coordFloat );

            return interpolated * 2.0 - 1.0;
        }

        float getHeight( float x, float y, float z )
        {
            float h = 0.5;
            for( int i = 0; i < 5; ++i )
            {
                float resolution = pow( 2.0, 2.0 + float( i ) * 2.0 );
                float level      = helper( x, y, z, resolution );

                h *= 1.0 + level * ( 0.8 / ( pow( 2.0, 1.0 + float( i ) ) ) );
            }

            h = clamp( h, 0.0, 1.0 );

            return h;
        }

        vec4 getCloud( float x, float y, float z )
        {
            float h = 0.5;
            for( int i = 0; i < 7; ++i )
            {
                float resolution = pow( 2.0, 4.0 + float( i ) * 2.0 );
                float level      = helper( x, y, z, resolution );

                h *= 1.0 + level * ( 0.8 / ( pow( 2.0, 1.0 + float( i ) ) ) );
            }

            if(h < 0.6)
                h = 0.0;

            h = clamp( h, 0.0, 1.0 );

            // return vec4( 0.8, 0.8, 0.5, h );
            return vec4( 1.0, 1.0, 1.0, h );
        }

        vec4 getColor( float x, float y, float z, float height )
        {
            vec3 color;

            // Red / White
            if(height < 0.5)
            {
                color.r = height * 0.7;
                color.g = height * 0.2;
                color.b = height * 0.2;
            }

            else
            {
                color.r = height * 0.9;
                color.g = height * 0.2;
                color.b = height * 0.2;
            }

            float temp = height * abs( y );
            if( temp > 0.4 )
            {
                color.r = height * 0.8;
                color.g = height * 0.8;
                color.b = height * 0.5 + 0.5;
            }

            return vec4( color, 1.0 );
        }

        vec3 getSphericalCoord( int index, float x, float y, float width )
        {
            width *= 0.5;
            x     -= width;
            y     -= width;

            vec3 coord = vec3( 0.0, 0.0, 0.0 );

            if(index == 0)      { coord.x = width;   coord.y = - y;     coord.z = - x; }
            else if(index == 1) { coord.x = - width; coord.y = - y;     coord.z = x; }
            else if(index == 2) { coord.x = x;       coord.y = width;   coord.z = y; }
            else if(index == 3) { coord.x = x;       coord.y = - width; coord.z = - y; }
            else if(index == 4) { coord.x = x;       coord.y = - y;     coord.z = width; }
            else if(index == 5) { coord.x = - x;     coord.y = - y;     coord.z = - width; }

            return normalize( coord );
        }

        void main()
        {
            float x = vUv.x;
            float y = 1.0 - vUv.y;

            // Get sphetical coordinates
            vec3 sphericalCoord = getSphericalCoord( index, x * 1024.0, y * 1024.0, 1024.0 );

            // Get height
            float height = getHeight( sphericalCoord.x, sphericalCoord.y, sphericalCoord.z );

            // Get color
            vec4 color = getColor( sphericalCoord.x, sphericalCoord.y, sphericalCoord.z, height );

            // Get cloud
            seed = vec3( 78.233, 1.23456, 12.9898 ); // Change seed
            vec4 cloud = getCloud( sphericalCoord.x, sphericalCoord.y, sphericalCoord.z );

            // gl_FragColor = mix( color, cloud, cloud.a );
            // gl_FragColor = mix( color, vec4(1) * color + vec4(1.0) * cloud, cloud.a );
            // gl_FragColor = vec4(0.5) * color + vec4(0.5) * cloud;
            gl_FragColor = color;
        }

    </script>

    <!-- LIBS : MISC -->
    <script src="src/js/libs/dat.gui.min.js"></script>
    <script src="src/js/libs/rStats.js"></script>
    <script src="src/js/libs/jquery-2.1.1.min.js"></script>
    <script src="src/js/libs/class.js"></script>
    <script src="src/js/libs/matter-0.8.0.min.js"></script>
    <script src="src/js/libs/howler.min.js"></script>

    <!-- LIBS : THREE -->
    <script src="src/js/libs/three-js/three.min.js"></script>
    <script src="src/js/libs/three-js/shaders/AdditiveBlendingShader.js"></script>
    <script src="src/js/libs/three-js/shaders/ConvolutionShader.js"></script>
    <script src="src/js/libs/three-js/shaders/CopyShader.js"></script>
    <script src="src/js/libs/three-js/shaders/VerticalBlurShader.js"></script>
    <script src="src/js/libs/three-js/shaders/HorizontalBlurShader.js"></script>
    <script src="src/js/libs/three-js/shaders/VerticalTiltShiftShader.js"></script>
    <script src="src/js/libs/three-js/shaders/HorizontalTiltShiftShader.js"></script>
    <script src="src/js/libs/three-js/shaders/BrightnessContrastShader.js"></script>
    <script src="src/js/libs/three-js/shaders/FXAAShader.js"></script>
    <script src="src/js/libs/three-js/shaders/ColorCorrectionShader.js"></script>
    <script src="src/js/libs/three-js/postprocessing/EffectComposer.js"></script>
    <script src="src/js/libs/three-js/postprocessing/BloomPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/RenderPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/ShaderPass.js"></script>
    <script src="src/js/libs/three-js/postprocessing/MaskPass.js"></script>

    <!-- APP -->
    <script src="src/js/app/app.js"></script>

    <!-- CORE -->
    <script src="src/js/app/core/abstract.class.js"></script>
    <script src="src/js/app/core/event_emitter.class.js"></script>
    <script src="src/js/app/core/app.class.js"></script>

    <!-- COMPONENTS -->
    <script src="src/js/app/components/debug.class.js"></script>
    <script src="src/js/app/components/ui.class.js"></script>
    <script src="src/js/app/components/sounds.class.js"></script>
    <script src="src/js/app/components/world/world.class.js"></script>
    <script src="src/js/app/components/world/renderer.class.js"></script>
    <script src="src/js/app/components/world/planet/planet.class.js"></script>
    <script src="src/js/app/components/world/planet/sky.class.js"></script>
    <script src="src/js/app/components/world/planet/ground.class.js"></script>

    <!-- TOOLS -->
    <script src="src/js/app/tools/browser.class.js"></script>
    <script src="src/js/app/tools/css.class.js"></script>
    <script src="src/js/app/tools/images.class.js"></script>
    <script src="src/js/app/tools/three_helper.class.js"></script>
    <script src="src/js/app/tools/keyboard.class.js"></script>
    <script src="src/js/app/tools/mouse.class.js"></script>
    <script src="src/js/app/tools/ticker.class.js"></script>

    <script>
        var app = new APP.CORE.App();
        app.start();
    </script>
</body>
</html>
